<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width,initial-scale=1.0" name="viewport">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="Building and developing the system." name="description">
    <title>Team 25 - Implementation</title>
    <link href="assets/styles/main.css" rel="stylesheet">
    <link href="assets/styles/implementation.css" rel="stylesheet">

    <script src="https://unpkg.com/ionicons@5.2.3/dist/ionicons/ionicons.esm.js" type="module"></script>
    <script nomodule="" src="https://unpkg.com/ionicons@5.2.3/dist/ionicons/ionicons.js"></script>
    <script crossorigin="anonymous"
            integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
            src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script defer>
        $(function () {
            $("#navbar").load("navbar.html");
            $("#footer").load("footer.html");
        });
    </script>
</head>
<body>
<header id="navbar"></header>
<div class="page">
    <div class="header-card">
        <div class="page-header">
            <h1>System<br>Development</h1>
            <p>Here we highlight some key features and algorithms of our system and how were they implemented. </p>
        </div>
        <div class="image-container noselect"></div>
        <script>
            let title = document.querySelector(".page-header h1");
            let subtitle = document.querySelector(".page-header p");
            const resize = function (subtitle) {
                subtitle.style.maxWidth = title.clientWidth.toString() + "px";
            };
            window.onresize = window.onload = () => {
                resize(subtitle);
            };
        </script>
    </div>

    <section class="main-technologies centred">
        <h2>Main Technologies</h2>
        <p>As shown in our research, our main technologies are <b>Vue.js</b> <i>(web app in JavaScript)</i>, <b>Android
            Studio</b><i>(Android App in Java)</i>, <b>IBM Cloud DB2</b> <i>(Cloud database)</i>,
            <b>Java</b> <i>(for the backend and services API)</i> and <b>Google Firebase</b><i>(media storage)</i>
        </p>
        <div class="logo-row centred">
            <div class="image-container">
                <img alt="Vue.js" src="assets/images/implementation/vuejs.webp">
            </div>
            <div class="image-container">
                <img alt="Android" src="assets/images/implementation/android.jpg">
            </div>
            <div class="image-container">
                <img alt="IBM Cloud DB2" src="assets/images/implementation/ibm-db2.jpg">
            </div>
            <div class="image-container">
                <img alt="Java" src="assets/images/implementation/java.png">
            </div>
            <div class="image-container">
                <img alt="Google Firebase" src="assets/images/implementation/firebase.png">
            </div>
        </div>
        <p>All Java components will be managed using the <b>Maven</b> build tool.</p>
        <div class="image-container">
            <img alt="Maven" src="assets/images/implementation/maven.png">
        </div>
        <p>We will also be using the Java <b>SpringBoot</b> dependency which allows us to create simple RESTful APIs
            with little
            overhead code.</p>
        <div class="image-container">
            <img alt="SpringBoot" src="assets/images/implementation/spring-boot.png">
        </div>
    </section>

    <section class="web-app centred light-page-section">
        <h2>Admin Web App</h2>
        <p></p>
        <div class="web-app-section centred">
            <h3>Responsive Design</h3>
            <p>The web app is designed to be usable on any device with a browser (with JavaScript enabled) and as such
                required care into ensuring it worked on any (modern) browser on any screen size and orientation. To
                facilitate this, the mobile-first design pattern was implemented using CSS – the styles for each
                component (button, header, input etc.) are designed to be usable on mobile devices. Once the appearance
                was up to standard, extra cases were added (using CSS media queries) to make use of the space afforded
                by larger devices.</p>
            <div class="image-container">
                <img alt="An example of the CSS Media queries used" src="">
            </div>
            <p>Several implementation iterations were carried out, testing the appearance on multiple browsers, screen
                sizes and orientations. Screenshots are shown below:</p>
            <div class="image-container">
                <img alt="The Concierge web app on different devices" src="">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Accessibility</h3>
            <p>The web app must be user-friendly to all types of users, including those less able. To ensure this was
                true, standard HTML semantics were followed (e.g., using the <span
                       >&lt;button&gt;</span> tag for buttons instead of div
                elements; splitting pages into section elements and ensuring headings followed the <i>h1, h2, h3</i>
                etc.
                pattern in order).</p>
            <p>This approach makes the website more screen reader friendly so more users can use the web app. Naturally,
                we are not experts on this, and our implementation is likely far from perfect, but accessibility was
                always kept in mind during the implementation phase.</p>
        </div>

        <div class="web-app-section centred">
            <h3>Data Fetching</h3>
            <p>To communicate with the backend, the <a rel="noopener" target="_blank" href="https://github.com/axios/axios">Axios</a> Node module was
                used to make RESTful API calls to the
                backend;
                this was then wrapped in a set of methods to act as a further abstraction between the backend and the
                frontend. Axios is a popular and mature library but should we want to switch to another data-fetching
                library, only the content of the wrapper methods needs to be changed- the frontend can remain the
                same.</p>
            <p>Given Vue’s reactive nature, the data provided on the website can be populated when it is ready (i.e.,
                returned by the backend). To facilitate this, JavaScript’s Promise API was used with asynchronous
                data-fetching methods.</p>
            <p>Naturally, API calls take some non-zero time to make and receive a response from – the website should not
                be frozen while waiting for this data otherwise it would completely hamper the user experience; this
                problem would worsen for users on slower internet connections.</p>
            <p>In essence, when performing an API call with the
                <code>axios.request()</code>
                method, the object returned is a <b>Promise</b>. A
                <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>
                is an object representing the eventual completion or failure of an asynchronous operation (MDN
                Web Docs, 2021). The backend response was wrapped in a Promise (by the axios library) which resolves
                into the JSON response when the backend responds; this happens automatically, handled by the Promise
                API.</p>
            <p>As a result, we could make API calls and then set the required data when a response is received; once
                received, Vue’s reactive nature will then repaint the DOM to display this data.</p>
            <p>Naturally, some methods require the data to be populated before they can run. To facilitate this, the
                await keyword can be used in asynchronous methods to pause execution in that method until the Promise
                resolves. However, it is important to note that this does not block the callee method as asynchronous
                methods return a Promise, so the callee is free to continue executing if needed.</p>
            <p>In short, Vue’s reactive nature, coupled with JavaScript’s built-in asynchronous features, allows us to
                maximise the performance of the web app with little overhead code without idling, waiting for a backend
                response. </p>
            <div class="image-container">
                <img alt="Code snippet of the code using to communicate with the backend" src="">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Vuex Store</h3>
            <p>Naturally, some data needs to persist between sessions. The <i>Vue store</i> (provided by the <a
                    href="https://next.vuex.vuejs.org">Vuex</a>
                library) is a mechanism allowing for persistent data storage.</p>
            <p>Vuex is a state management pattern + library for Vue.js applications. It serves as a centralised store
                for all the components in an application, with rules ensuring that the state can only be mutated in a
                predictable fashion (Vuex Documentation, 2021).</p>
            <p>In the web app, Vuex is used to store the username of the logged-in user. This prevents the user from
                having to login whenever they switch pages and also allows them to remain logged in even after exiting
                the web app. The username is cleared from the store when the user manually logs out.</p>
            <p>Additionally, the store was used as an interface between the frontend components and the set of wrapper
                methods used to make axios API calls to the backend. Vuex is an extension of Vue.js, so the interaction
                between the two is natural and intuitive. Instead of the frontend directly making API calls, it
                interacts with the store; if the endpoints, or structure of messages changes, the frontend can remain
                the same – only the store needs to be modified.</p>
            <p>To reduce bandwidth, images were also cached in the Vuex store meaning they do not need to be continually
                fetched from elsewhere whenever the admin visits the website. It is important to note that if more
                images were to be added, the Vuex store would need to be cleared (which can be done
                programmatically).</p>
            <div class="image-container">
                <img alt="Code snippet of the code used to interact with the store" src="">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Media Storage</h3>
            <p>The web app uses profile pictures to differentiate between app users assigned to an admin (in case they
                have the same name). Icons for each service are used to make the user experience more aesthetically
                pleasing.</p>
            <p>However, we decided we would not store these images in the cloud database as this would eat into our
                already limited IBM cloud storage quota (as we are on the free plan) which negatively affects the
                scalability of our solution – we would have to pay to increase our storage quota. Additionally, we would
                need to encode the images as binary text and then insert it; this would make database maintenance very
                difficult (e.g., we would not know if we’ve inserted the correct image as we cannot see it in the cloud
                database console).</p>
            <p>Instead, images were stored in a <a rel="noopener" target="_blank" href="https://firebase.google.com">Google Firebase bucket</a> and
                accessed using Firebase’s JavaScript
                API. Accessing these images returns a download link which we can directly insert into an image tag in
                HTML. Images can then be easily modified as well as essentially providing us with more storage to work
                with for free.</p>
            <p>In the cloud database, these images are referenced by their filename which the web app uses when
                searching the Firebase bucket.</p>
            <p>Note that all images were converted into the <code>.webp</code> file format to
                reduce file sizes (and hence, bandwidth) with
                no loss in image quality. Images were also scaled down so their size was the maximum size the image
                would ever be when displayed on the website.</p>
            <div class="image-container">
                <img alt="Screenshot of Firebase bucket" src="">
            </div>
            <div class="image-container">
                <img alt="Code snippet of the code used to access the Firebase bucket" src="">
            </div>
        </div>

    </section>
	
	<section>
		<h2>Android App</h2>
		<p>See implementation details for the app below.</p>
		<div>
			<h3>Main Technologies</h3>
			<p>The app was programmed in Java using the Android Studio IDE and its built in features such as the Profiler.</p>
		</div>
		<div>
			<h3>Dependencies & Tools</h3>
			<p>We used several external libraries beyond the standard Java and Android libraries to help us develop and test our app. See the different sections below.</p>
		</div>
		<div>
			<h3>Android APIs</h3>
			<p>We made extensive use of the built in Android APIs for features such as searching contacts, making calls and providing notifications.-> saved time, code, better code quality, well tested, ensured compatibility</p></p>
			<p>We also used built in speech recognition and speech synthesis for our app as this satisfied our MoSCoW requirements and 
			allowed us to focus on other parts of the system. Furthermore, this provides the added benefit that as the Android speech 
			recognition and speech synthesis improves, our app will automatically benefit and be able to use this updated software.</p>
			<h4>Built in SQLite 3 DB, -> Alarms, Reminders</h4>
			<p>We utilised the built in SQLite database that comes with Android for our Alarms and Reminders. We also used this to store 
			user details after connecting to their admin. Fast, no privacy concerns, convenient, reliable, act as a framework for developers</p>
			<h4>Built in widgets like DateFragment, NumberPickerFragment -> Timers</h4>
			<p>Some of our features required widgets for example Alarms required widgets for choosing the date and time. For our Timers 
			feature, we also used the NumberPicker widgets. Reasons for this are the same as for using Android APIs[provide screenshots] </p>
		</div>
		<div>
			<h3>Java</h3>
			<h4>Java 13</h4>
			<p>We used Java 13 to program our app as it was the most up to date Java version and provided many standard, well tested, well maintained libraries which we could use.</p>
			<h4>Data Structures - HashMaps, JSON, ArrayLists, Arrays, Strings, primitives -> booleans</h4>
			<p>We used many data structures in our app. The most notable one was HashMaps. This was used to store key value pairs after parsing the JSON response
			from Ask Bob which would then be used by the AskBobResponseController to decide which method in MainController to call. We used HashMaps 
			as they provide O(1) time complexity for searching. We used them for their efficiency. It would mean that we could respond to user requests more
			quickly. They also come with a variety of built in methods that were very useful such as contains() which was needed at several points to quickly 
			check what sort of a request the user had made (Service API, Lookup etc) and respond appropriately. It also prevented the app from crashing
			due to NullPointerExceptions as we could check if the hashmap contained a particular key or not before asking for it through the get() method. The 
			O(1) time complexity came into use here too. 
			Aside from this, we used other data structures such as ArrayLists and Strings to pass data around our app appropriately. These data structures also
			came with a nice interface [mention API name from Soft Eng] which made working with them easier than raw data structures such as arrays. 
			We also used booleans, ints and other primitive data types. We used these when there was no need to use more complex data structures which made our
			app faster and meant it took less RAM.</p>
			<h4>Other Java Libraries</h4>
			<p>We used other standard Java libraries such as HttpUrlConnection (for connecting to the backend and Ask Bob servers) throughout the app. </p>
		</div>
		<div>
			<h3>Other Major Libraries</h3>
			<h4>Espresso</h4>
			<p>This library was used to write Instrumentation tests. Please refer to the testing section for further details.</p>
			<h4>Robolectric</h4>
			<p>This library was used to write unit/integration tests. Please refer to the testing section for further details. </p>
			<h4>Monkey</h4>
			<p>This library was used for stress testing. Please refer to the testing section for further details.</p>
			<h4>AndroidJUnit4Runner</h4>
			<p>This library was used to run Instrumentation tests. Please refer to the testing section for further details.</p>
			<h4>org.json</h4>
			<p>This library was used to parse the JSON response from the Ask Bob Server.</p>
			<h4>JacksonCore, jacksondatabind </h4>
			<p></p>
			<h4>Backend and Ask Bob Server</h4>
			<p>The app makes use of the Ask Bob server to send user requests and receive a JSON response which the app can use to decide which action to take. 
			See...for details on what we use the Ask Bob server for exactly. We also make use of our backend server to connect them with their admin and provide
			them with the functionality this entails such as their history.</p>
			<h4>Offline NLP from Ask Bob</h4>
			<p>The app utilises the Ask Bob server's NLP framework to interpret user requests.</p>
		</div>
		<div>
			<h3>Minor Libraries Used</h3>
			<h4>GetLocationApi</h4>
			<p>This API is used to convert the user's latitude and longitude into a postcode for services which require this such as Yell searches.</p>
			<h4>PlayServices</h4>
			<p>This Google library is used as part of getting the user's latitude and longitude which is used for certain services such as opening Google Maps 
			and finding the nearest bus/train station.</p>
		</div>
	</section>

    <section class="ask-bob-integration">
        <h2>AskBob Integration</h2>
        <p>An integral part of our system is the Concierge Voice Assistant. This voice assistant is powered by the
            AskBob RESTful API which is deployed locally and will allow users to utilise the voice assistant within the
            app. This AskBob API receives the users command from the Concierge app in plain text. It then employee’s
            natural language processing to decode the intent behind command and then calls our Service API to retrieve
            the necessary information required to fulfil this request. This data is then returned to the app where the
            appropriate action can be triggered. </p>
        <p>This AskBob API was developed using Team 39’s AskBob NLP framework. This framework is based upon the Python
            library Rasa which is designed for building chatbots. Originally, we had been utilising Spacy to perform our
            natural language processing. In this case we designed and trained our own NLP Spacy model and were then
            running it as an API using the Python Library Flask. However, our clients requested that we integrate some
            of our services with the other 2 IBM groups (Team 39 and Team 38). As part of this integration, we were
            instructed to transition to the AskBob NLP framework for our voice assistant to ensure consistency across
            the FISE ecosystem. This involved transferring the services that we had already designed to the AskBob
            framework. </p>
        <h3>Structure</h3>
        <p>As mentioned above the AskBob API is intended to be deployed on a local network as specified in our MOSCOW
            requirements. The AskBob API is intended to receive a user’s command in plain text from the app which is
            acquired having the app perform speech recognition on the user’s verbal request. This request is then
            processed, and the appropriate data required to fulfil the request is retrieved from our service API. For
            the AskBob API to perform this, it is reliant on also having the service API running locally. </p>
        <h3>Adding Plugins</h3>
        <p>Services are added to the AskBob API in the form of plugins. Plugins are collections of services and the
            general Concierge plugin consists of three main files: an __init__.py file, an actions.py file and a
            config.json file. Within these files all the data required to implement a service is contained. </p>
        <h4>The <code>__init__.py</code> File</h4>
        <p>The purpose of the <code>__init__.py</code> file is to mark the plugin folder as a
            Python package. </p>
        <h4>The <code>config.json</code> File</h4>
        <p>The config file is used to define the skills within a given plugin. Skills refers to the to a specific
            service within the plugin. At its core a skill is comprised of an intent and an action. The intent can be
            understood as what the user is attempting to achieve, and the action is the process that is triggered by a
            specific intent. When defining an intent multiple sample commands must be provided as this is what the NLP
            model will train from. Actions on the other hand will be defined within the <code>actions.py</code>
            file. </p>
        <p>Additionally, certain skills may require data to be extracted from the user’s command. This data is referred
            to as entities and must also be defined in the config file. For more information on the syntax of a config
            file see <a rel="noopener" target="_blank" href="https://github.com/UCL-COMP0016-2020-Team-39/AskBob">Team 39's GitHub repository</a>. </p>
        <p>Below is a sample config file for the weather service: </p>
        <div class="image-container">
            <img alt="An example AskBob config.json file" src="">
        </div>
        <h4>The <code>actions.py</code> File</h4>
        <p>The actions.py file contains is where the actions for a given skill must be defined. Each action is defined
            as its own class. The code defined within this file will trigger when a given intent is recognised. For the
            majority of the Concierge an action will consist of extracting the necessary entities required by the
            service API and then placing a request to the specific service API endpoint to retrieve the necessary
            response. This response is then returned as a JSON data package with the following format: </p>
        <div class="image-container">
            <img alt="An example JSON response" src="">
        </div>
        <p>Below is an action class for the weather service that is defined by the config class. </p>
        <div class="image-container">
            <img alt="An example AskBob actions.py file" src="">
        </div>
    </section>

    <section class="light-page-section centred">
        <h2>References</h2>
    </section>

</div>
<footer id="footer"></footer>
</body>
</html>