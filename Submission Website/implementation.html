<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Building and developing the system.">
    <title>Team 25 - Implementation</title>
    <link rel="stylesheet" href="assets/styles/main.css">
    <link rel="stylesheet" href="assets/styles/implementation.css">

    <script type="module" src="https://unpkg.com/ionicons@5.2.3/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule="" src="https://unpkg.com/ionicons@5.2.3/dist/ionicons/ionicons.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
            integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
            crossorigin="anonymous"></script>
    <script defer>
        $(function () {
            $("#navbar").load("navbar.html");
            $("#footer").load("footer.html");
        });
    </script>
</head>
<body>
<header id="navbar"></header>
<div class="page">
    <div class="header-card">
        <div class="page-header">
            <h1>System<br>Development</h1>
            <p></p>
        </div>
        <div class="image-container noselect"></div>
        <script>
            let title = document.querySelector(".page-header h1");
            let subtitle = document.querySelector(".page-header p");
            const resize = function (subtitle) {
                subtitle.style.maxWidth = title.clientWidth.toString() + "px";
            };
            window.onresize = window.onload = () => {
                resize(subtitle);
            };
        </script>
    </div>

    <section class="web-app centred">
        <h2>Admin Web App</h2>
        <p></p>
        <div class="web-app-section centred">
            <h3>Responsive Design</h3>
            <p>The web app is designed to be usable on any device with a browser (with JavaScript enabled) and as such
                required care into ensuring it worked on any (modern) browser on any screen size and orientation. To
                facilitate this, the mobile-first design pattern was implemented using CSS – the styles for each
                component (button, header, input etc.) are designed to be usable on mobile devices. Once the appearance
                was up to standard, extra cases were added (using CSS media queries) to make use of the space afforded
                by larger devices.</p>
            <div class="image-container">
                <img src="" alt="An example of the CSS Media queries used">
            </div>
            <p>Several implementation iterations were carried out, testing the appearance on multiple browsers, screen
                sizes and orientations. Screenshots are shown below:</p>
            <div class="image-container">
                <img src="" alt="The Concierge web app on different devices">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Accessibility</h3>
            <p>The web app must be user-friendly to all types of users, including those less able. To ensure this was
                true, standard HTML semantics were followed (e.g., using the <span
                        class="code-snippet">&lt;button&gt;</span> tag for buttons instead of div
                elements; splitting pages into section elements and ensuring headings followed the <i>h1, h2, h3</i>
                etc.
                pattern in order).</p>
            <p>This approach makes the website more screen reader friendly so more users can use the web app. Naturally,
                we are not experts on this, and our implementation is likely far from perfect, but accessibility was
                always kept in mind during the implementation phase.</p>
        </div>

        <div class="web-app-section centred">
            <h3>Data Fetching</h3>
            <p>To communicate with the backend, the <a href="https://github.com/axios/axios">Axios</a> Node module was
                used to make RESTful API calls to the
                backend;
                this was then wrapped in a set of methods to act as a further abstraction between the backend and the
                frontend. Axios is a popular and mature library but should we want to switch to another data-fetching
                library, only the content of the wrapper methods needs to be changed- the frontend can remain the
                same.</p>
            <p>Given Vue’s reactive nature, the data provided on the website can be populated when it is ready (i.e.,
                returned by the backend). To facilitate this, JavaScript’s Promise API was used with asynchronous
                data-fetching methods.</p>
            <p>Naturally, API calls take some non-zero time to make and receive a response from – the website should not
                be frozen while waiting for this data otherwise it would completely hamper the user experience; this
                problem would worsen for users on slower internet connections.</p>
            <p>In essence, when performing an API call with the
                <span class="code-snippet">axios.request()</span>
                method, the object returned is a <b>Promise</b>. A
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>
                is an object representing the eventual completion or failure of an asynchronous operation (MDN
                Web Docs, 2021). The backend response was wrapped in a Promise (by the axios library) which resolves
                into the JSON response when the backend responds; this happens automatically, handled by the Promise
                API.</p>
            <p>As a result, we could make API calls and then set the required data when a response is received; once
                received, Vue’s reactive nature will then repaint the DOM to display this data.</p>
            <p>Naturally, some methods require the data to be populated before they can run. To facilitate this, the
                await keyword can be used in asynchronous methods to pause execution in that method until the Promise
                resolves. However, it is important to note that this does not block the callee method as asynchronous
                methods return a Promise, so the callee is free to continue executing if needed.</p>
            <p>In short, Vue’s reactive nature, coupled with JavaScript’s built-in asynchronous features, allows us to
                maximise the performance of the web app with little overhead code without idling, waiting for a backend
                response. </p>
            <div class="image-container">
                <img src="" alt="Code snippet of the code using to communicate with the backend">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Vuex Store</h3>
            <p>Naturally, some data needs to persist between sessions. The <i>Vue store</i> (provided by the <a
                    href="https://next.vuex.vuejs.org">Vuex</a>
                library) is a mechanism allowing for persistent data storage.</p>
            <p>Vuex is a state management pattern + library for Vue.js applications. It serves as a centralised store
                for all the components in an application, with rules ensuring that the state can only be mutated in a
                predictable fashion (Vuex Documentation, 2021).</p>
            <p>In the web app, Vuex is used to store the username of the logged-in user. This prevents the user from
                having to login whenever they switch pages and also allows them to remain logged in even after exiting
                the web app. The username is cleared from the store when the user manually logs out.</p>
            <p>Additionally, the store was used as an interface between the frontend components and the set of wrapper
                methods used to make axios API calls to the backend. Vuex is an extension of Vue.js, so the interaction
                between the two is natural and intuitive. Instead of the frontend directly making API calls, it
                interacts with the store; if the endpoints, or structure of messages changes, the frontend can remain
                the same – only the store needs to be modified.</p>
            <p>To reduce bandwidth, images were also cached in the Vuex store meaning they do not need to be continually
                fetched from elsewhere whenever the admin visits the website. It is important to note that if more
                images were to be added, the Vuex store would need to be cleared (which can be done
                programmatically).</p>
            <div class="image-container">
                <img src="" alt="Code snippet of the code used to interact with the store">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Media Storage</h3>
            <p>The web app uses profile pictures to differentiate between app users assigned to an admin (in case they
                have the same name). Icons for each service are used to make the user experience more aesthetically
                pleasing.</p>
            <p>However, we decided we would not store these images in the cloud database as this would eat into our
                already limited IBM cloud storage quota (as we are on the free plan) which negatively affects the
                scalability of our solution – we would have to pay to increase our storage quota. Additionally, we would
                need to encode the images as binary text and then insert it; this would make database maintenance very
                difficult (e.g., we would not know if we’ve inserted the correct image as we cannot see it in the cloud
                database console).</p>
            <p>Instead, images were stored in a <a href="https://firebase.google.com">Google Firebase bucket</a> and
                accessed using Firebase’s JavaScript
                API. Accessing these images returns a download link which we can directly insert into an image tag in
                HTML. Images can then be easily modified as well as essentially providing us with more storage to work
                with for free.</p>
            <p>In the cloud database, these images are referenced by their filename which the web app uses when
                searching the Firebase bucket.</p>
            <p>Note that all images were converted into the <span class="code-snippet">.webp</span> file format to
                reduce file sizes (and hence, bandwidth) with
                no loss in image quality. Images were also scaled down so their size was the maximum size the image
                would ever be when displayed on the website.</p>
            <div class="image-container">
                <img src="" alt="Screenshot of Firebase bucket">
            </div>
            <div class="image-container">
                <img src="" alt="Code snippet of the code used to access the Firebase bucket">
            </div>
        </div>

    </section>

    <section class="light-page-section centred">
        <h2>References</h2>
    </section>

</div>
<footer id="footer"></footer>
</body>
</html>