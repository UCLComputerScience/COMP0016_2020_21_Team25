<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Building and developing the system.">
    <title>Team 25 - Implementation</title>
    <link rel="stylesheet" href="assets/styles/main.css">
    <link rel="stylesheet" href="assets/styles/implementation.css">

    <script type="module" src="https://unpkg.com/ionicons@5.2.3/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule="" src="https://unpkg.com/ionicons@5.2.3/dist/ionicons/ionicons.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
            integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
            crossorigin="anonymous"></script>
    <script defer>
        $(function () {
            $("#navbar").load("navbar.html");
            $("#footer").load("footer.html");
        });
    </script>
</head>
<body>
<header id="navbar"></header>
<div class="page">
    <div class="header-card">
        <div class="page-header">
            <h1>System<br>Development</h1>
            <p>Here we highlight some key features and algorithms of our system and how were they implemented. </p>
        </div>
        <div class="image-container noselect"></div>
        <script>
            let title = document.querySelector(".page-header h1");
            let subtitle = document.querySelector(".page-header p");
            const resize = function (subtitle) {
                subtitle.style.maxWidth = title.clientWidth.toString() + "px";
            };
            window.onresize = window.onload = () => {
                resize(subtitle);
            };
        </script>
    </div>

    <section class="main-technologies centred">
        <h2>Main Technologies</h2>
        <p>As shown in our research, our main technologies are <b>Vue.js</b> <i>(web app in JavaScript)</i>, <b>Android
            Studio</b><i>(Android App in Java)</i>, <b>IBM Cloud DB2</b> <i>(Cloud database)</i>,
            <b>Java</b> <i>(for the backend and services API)</i> and <b>Google Firebase</b><i>(media storage)</i>
        </p>
        <div class="logo-row centred">
            <div class="image-container">
                <img src="assets/images/implementation/vuejs.webp" alt="Vue.js">
            </div>
            <div class="image-container">
                <img src="assets/images/implementation/android.jpg" alt="Android">
            </div>
            <div class="image-container">
                <img src="assets/images/implementation/ibm-db2.jpg" alt="IBM Cloud DB2">
            </div>
            <div class="image-container">
                <img src="assets/images/implementation/java.png" alt="Java">
            </div>
            <div class="image-container">
                <img src="assets/images/implementation/firebase.png" alt="Google Firebase">
            </div>
        </div>
        <p>All Java components will be managed using the <b>Maven</b> build tool.</p>
        <div class="image-container">
            <img src="assets/images/implementation/maven.png" alt="Maven">
        </div>
        <p>We will also be using the Java <b>SpringBoot</b> dependency which allows us to create simple RESTful APIs
            with little
            overhead code.</p>
        <div class="image-container">
            <img src="assets/images/implementation/spring-boot.png" alt="SpringBoot">
        </div>
    </section>

    <section class="web-app centred light-page-section">
        <h2>Admin Web App</h2>
        <p></p>
        <div class="web-app-section centred">
            <h3>Responsive Design</h3>
            <p>The web app is designed to be usable on any device with a browser (with JavaScript enabled) and as such
                required care into ensuring it worked on any (modern) browser on any screen size and orientation. To
                facilitate this, the mobile-first design pattern was implemented using CSS – the styles for each
                component (button, header, input etc.) are designed to be usable on mobile devices. Once the appearance
                was up to standard, extra cases were added (using CSS media queries) to make use of the space afforded
                by larger devices.</p>
            <div class="image-container">
                <img src="" alt="An example of the CSS Media queries used">
            </div>
            <p>Several implementation iterations were carried out, testing the appearance on multiple browsers, screen
                sizes and orientations. Screenshots are shown below:</p>
            <div class="image-container">
                <img src="" alt="The Concierge web app on different devices">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Accessibility</h3>
            <p>The web app must be user-friendly to all types of users, including those less able. To ensure this was
                true, standard HTML semantics were followed (e.g., using the <span
                        class="code-snippet">&lt;button&gt;</span> tag for buttons instead of div
                elements; splitting pages into section elements and ensuring headings followed the <i>h1, h2, h3</i>
                etc.
                pattern in order).</p>
            <p>This approach makes the website more screen reader friendly so more users can use the web app. Naturally,
                we are not experts on this, and our implementation is likely far from perfect, but accessibility was
                always kept in mind during the implementation phase.</p>
        </div>

        <div class="web-app-section centred">
            <h3>Data Fetching</h3>
            <p>To communicate with the backend, the <a href="https://github.com/axios/axios">Axios</a> Node module was
                used to make RESTful API calls to the
                backend;
                this was then wrapped in a set of methods to act as a further abstraction between the backend and the
                frontend. Axios is a popular and mature library but should we want to switch to another data-fetching
                library, only the content of the wrapper methods needs to be changed- the frontend can remain the
                same.</p>
            <p>Given Vue’s reactive nature, the data provided on the website can be populated when it is ready (i.e.,
                returned by the backend). To facilitate this, JavaScript’s Promise API was used with asynchronous
                data-fetching methods.</p>
            <p>Naturally, API calls take some non-zero time to make and receive a response from – the website should not
                be frozen while waiting for this data otherwise it would completely hamper the user experience; this
                problem would worsen for users on slower internet connections.</p>
            <p>In essence, when performing an API call with the
                <span class="code-snippet">axios.request()</span>
                method, the object returned is a <b>Promise</b>. A
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>
                is an object representing the eventual completion or failure of an asynchronous operation (MDN
                Web Docs, 2021). The backend response was wrapped in a Promise (by the axios library) which resolves
                into the JSON response when the backend responds; this happens automatically, handled by the Promise
                API.</p>
            <p>As a result, we could make API calls and then set the required data when a response is received; once
                received, Vue’s reactive nature will then repaint the DOM to display this data.</p>
            <p>Naturally, some methods require the data to be populated before they can run. To facilitate this, the
                await keyword can be used in asynchronous methods to pause execution in that method until the Promise
                resolves. However, it is important to note that this does not block the callee method as asynchronous
                methods return a Promise, so the callee is free to continue executing if needed.</p>
            <p>In short, Vue’s reactive nature, coupled with JavaScript’s built-in asynchronous features, allows us to
                maximise the performance of the web app with little overhead code without idling, waiting for a backend
                response. </p>
            <div class="image-container">
                <img src="" alt="Code snippet of the code using to communicate with the backend">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Vuex Store</h3>
            <p>Naturally, some data needs to persist between sessions. The <i>Vue store</i> (provided by the <a
                    href="https://next.vuex.vuejs.org">Vuex</a>
                library) is a mechanism allowing for persistent data storage.</p>
            <p>Vuex is a state management pattern + library for Vue.js applications. It serves as a centralised store
                for all the components in an application, with rules ensuring that the state can only be mutated in a
                predictable fashion (Vuex Documentation, 2021).</p>
            <p>In the web app, Vuex is used to store the username of the logged-in user. This prevents the user from
                having to login whenever they switch pages and also allows them to remain logged in even after exiting
                the web app. The username is cleared from the store when the user manually logs out.</p>
            <p>Additionally, the store was used as an interface between the frontend components and the set of wrapper
                methods used to make axios API calls to the backend. Vuex is an extension of Vue.js, so the interaction
                between the two is natural and intuitive. Instead of the frontend directly making API calls, it
                interacts with the store; if the endpoints, or structure of messages changes, the frontend can remain
                the same – only the store needs to be modified.</p>
            <p>To reduce bandwidth, images were also cached in the Vuex store meaning they do not need to be continually
                fetched from elsewhere whenever the admin visits the website. It is important to note that if more
                images were to be added, the Vuex store would need to be cleared (which can be done
                programmatically).</p>
            <div class="image-container">
                <img src="" alt="Code snippet of the code used to interact with the store">
            </div>
        </div>

        <div class="web-app-section centred">
            <h3>Media Storage</h3>
            <p>The web app uses profile pictures to differentiate between app users assigned to an admin (in case they
                have the same name). Icons for each service are used to make the user experience more aesthetically
                pleasing.</p>
            <p>However, we decided we would not store these images in the cloud database as this would eat into our
                already limited IBM cloud storage quota (as we are on the free plan) which negatively affects the
                scalability of our solution – we would have to pay to increase our storage quota. Additionally, we would
                need to encode the images as binary text and then insert it; this would make database maintenance very
                difficult (e.g., we would not know if we’ve inserted the correct image as we cannot see it in the cloud
                database console).</p>
            <p>Instead, images were stored in a <a href="https://firebase.google.com">Google Firebase bucket</a> and
                accessed using Firebase’s JavaScript
                API. Accessing these images returns a download link which we can directly insert into an image tag in
                HTML. Images can then be easily modified as well as essentially providing us with more storage to work
                with for free.</p>
            <p>In the cloud database, these images are referenced by their filename which the web app uses when
                searching the Firebase bucket.</p>
            <p>Note that all images were converted into the <span class="code-snippet">.webp</span> file format to
                reduce file sizes (and hence, bandwidth) with
                no loss in image quality. Images were also scaled down so their size was the maximum size the image
                would ever be when displayed on the website.</p>
            <div class="image-container">
                <img src="" alt="Screenshot of Firebase bucket">
            </div>
            <div class="image-container">
                <img src="" alt="Code snippet of the code used to access the Firebase bucket">
            </div>
        </div>

    </section>

    <section class="ask-bob-integration">
        <h2>AskBob Integration</h2>
        <p>An integral part of our system is the Concierge Voice Assistant. This voice assistant is powered by the
            AskBob RESTful API which is deployed locally and will allow users to utilise the voice assistant within the
            app. This AskBob API receives the users command from the Concierge app in plain text. It then employee’s
            natural language processing to decode the intent behind command and then calls our Service API to retrieve
            the necessary information required to fulfil this request. This data is then returned to the app where the
            appropriate action can be triggered. </p>
        <p>This AskBob API was developed using Team 39’s AskBob NLP framework. This framework is based upon the Python
            library Rasa which is designed for building chatbots. Originally, we had been utilising Spacy to perform our
            natural language processing. In this case we designed and trained our own NLP Spacy model and were then
            running it as an API using the Python Library Flask. However, our clients requested that we integrate some
            of our services with the other 2 IBM groups (Team 39 and Team 38). As part of this integration, we were
            instructed to transition to the AskBob NLP framework for our voice assistant to ensure consistency across
            the FISE ecosystem. This involved transferring the services that we had already designed to the AskBob
            framework. </p>
        <h3>Structure</h3>
        <p>As mentioned above the AskBob API is intended to be deployed on a local network as specified in our MOSCOW
            requirements. The AskBob API is intended to receive a user’s command in plain text from the app which is
            acquired having the app perform speech recognition on the user’s verbal request. This request is then
            processed, and the appropriate data required to fulfil the request is retrieved from our service API. For
            the AskBob API to perform this, it is reliant on also having the service API running locally. </p>
        <h3>Adding Plugins</h3>
        <p>Services are added to the AskBob API in the form of plugins. Plugins are collections of services and the
            general Concierge plugin consists of three main files: an __init__.py file, an actions.py file and a
            config.json file. Within these files all the data required to implement a service is contained. </p>
        <h4>The <span class="code-snippet">__init__.py</span> File</h4>
        <p>The purpose of the <span class="code-snippet">__init__.py</span> file is to mark the plugin folder as a
            Python package. </p>
        <h4>The <span class="code-snippet">config.json</span> File</h4>
        <p>The config file is used to define the skills within a given plugin. Skills refers to the to a specific
            service within the plugin. At its core a skill is comprised of an intent and an action. The intent can be
            understood as what the user is attempting to achieve, and the action is the process that is triggered by a
            specific intent. When defining an intent multiple sample commands must be provided as this is what the NLP
            model will train from. Actions on the other hand will be defined within the <span class="code-snippet">actions.py</span>
            file. </p>
        <p>Additionally, certain skills may require data to be extracted from the user’s command. This data is referred
            to as entities and must also be defined in the config file. For more information on the syntax of a config
            file see <a href="https://github.com/UCL-COMP0016-2020-Team-39/AskBob">Team 39's GitHub repository</a>. </p>
        <p>Below is a sample config file for the weather service: </p>
        <div class="image-container">
            <img src="" alt="An example AskBob config.json file">
        </div>
        <h4>The <span class="code-snippet">actions.py</span> File</h4>
        <p>The actions.py file contains is where the actions for a given skill must be defined. Each action is defined
            as its own class. The code defined within this file will trigger when a given intent is recognised. For the
            majority of the Concierge an action will consist of extracting the necessary entities required by the
            service API and then placing a request to the specific service API endpoint to retrieve the necessary
            response. This response is then returned as a JSON data package with the following format: </p>
        <div class="image-container">
            <img src="" alt="An example JSON response">
        </div>
        <p>Below is an action class for the weather service that is defined by the config class. </p>
        <div class="image-container">
            <img src="" alt="An example AskBob actions.py file">
        </div>
    </section>

    <section class="light-page-section centred">
        <h2>References</h2>
    </section>

</div>
<footer id="footer"></footer>
</body>
</html>